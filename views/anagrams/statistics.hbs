<div class="container-fluid">

    <h3>Important</h3>
    <div class="row">
        There

        {{#if stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoffIsOne}}
            is
        {{else}}
            are
        {{/if}}

        <strong>{{formatNumber stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoff}}</strong>

        {{#if stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoffIsOne}}
            match
        {{else}}
            matches
        {{/if}}

        with an interesting factor above <strong>{{stats.interestingFactorCutoff}}</strong> that

        {{#if stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoffIsOne}}
            is
        {{else}}
            are
        {{/if}}

        not rejected, not retweeted, and not posted to tumblr.
    </div>
    <div class="row">
        There

        {{#if stats.countOfPendingQueuedMatchesIsOne}}
            is
        {{else}}
            are
        {{/if}}

        <strong>{{formatNumber stats.countOfPendingQueuedMatches}}</strong>

        {{#if stats.countOfPendingQueuedMatchesIsOne}}
            match
        {{else}}
            matches
        {{/if}}

        queued to be posted.
    </div>
    <h3>Fun</h3>
    <div class="row">
        There are <strong>{{formatNumber stats.countOfMatches}}</strong> total matches over approximately
        <strong>{{formatNumber stats.approximateCountOfTweets}}</strong> tweets. That's about
        <strong>{{formatNumber stats.tweetsPerMatch maximumFractionDigits="0"}}</strong> tweets per match!
    </div>
    <div class="row">
        There are <strong>{{formatNumber stats.countOfMatchesAboveCutoff}}</strong> matches with an interesting factor
        above
        <strong>{{stats.interestingFactorCutoff}}</strong>.
    </div>
    <div class="row">
        <strong>{{formatNumber stats.countOfRetweetedMatches}}</strong> matches have been retweeted.
        There should be <strong>{{stats.countOfRetweetedTweets}}</strong> retweeted tweets.
    </div>
    <div class="row">
        <strong>{{formatNumber stats.countOfRejectedMatches}}</strong> matches have been rejected.
    </div>
    <div class="row">
        The most recent match was created <strong>{{formatRelative stats.dateLastMatchCreated}}</strong> at
        <strong>{{formatTime stats.dateLastMatchCreated hour="numeric" minute="numeric"}}</strong> on
        <strong>{{formatTime stats.dateLastMatchCreated day="numeric" month="long" year="numeric" }}</strong>.
    </div>

    <h3>
        <button class="btn btn-sm btn-info js-collapse-button" data-toggle="collapse" data-target="#retweets-and-tumblr-posts-by-day-table"></button>
        Retweets and Tumblr posts made by day for the past <strong>{{stats.numberOfDaysToGetMatchesPerDay}}</strong> days:
    </h3>
    <div class="row">
        <div id="retweets-and-tumblr-posts-by-day-table" class="col-md-5 collapse in"></div>

        <script id="retweets-and-tumblr-posts-by-day-table-template" type="text/x-handlebars-template">
            <table class="table table-hover table-condensed">
                <thead>
                <tr>
                    <th>Day</th>
                    <th>Retweets</th>
                    <th>Tumblr posts</th>
                </tr>
                </thead>
                <tbody>
                \{{#each rows}}
                <tr>
                    <td>\{{formatTime day day="numeric" month="long" year="numeric"}}</td>
                    <td>\{{retweeted}}</td>
                    <td>\{{postedToTumblr}}</td>
                </tr>
                \{{/each}}
                </tbody>
            </table>
        </script>

        <div class="col-md-7">
            <svg id="retweets-and-tumblr-posts-by-day-chart" height="400"></svg>
        </div>
    </div>

    <h3>
        <button class="btn btn-sm btn-info js-collapse-button" data-toggle="collapse" data-target="#stats-by-date-created-table"></button>
        Stats by date match created for the past <strong>{{stats.numberOfDaysToGetMatchesPerDay}}</strong> days:
    </h3>
    <div id="stats-by-date-created-table" class="row collapse in col-md-12"></div>

    <script id="stats-by-date-created-table-template" type="text/x-handlebars-template">
        <table class="table table-hover table-condensed">
            <thead>
            <tr>
                <th>Day</th>
                <th>Matches created</th>
                <th>Attempted Approval</th>
                <th>Auto-rejected</th>
                <th>Retweeted</th>
                <th>Unretweeted</th>
                <th>Rejected</th>
                <th>Tumblr</th>
                <th>Unreviewed</th>
                <th>% Unreviewed</th>
                <th>% Retweeted</th>
                <th>% Approval Failure</th>
            </tr>
            </thead>
            <tbody>
            \{{#each rows}}
                <tr>
                    <td>\{{formatTime day day="numeric" month="long" year="numeric"}}</td>
                    <td>\{{matchesCreated}}</td>
                    <td>\{{attemptedApproval}}</td>
                    <td>\{{autoRejected}}</td>
                    <td>\{{retweeted}}</td>
                    <td>\{{unretweeted}}</td>
                    <td>\{{rejected}}</td>
                    <td>\{{postedToTumblr}}</td>
                    <td>\{{unreviewed}}</td>
                    <td>\{{formatNumber percentUnreviewed style="percent"}}</td>
                    <td>\{{formatNumber percentRetweeted style="percent"}}</td>
                    <td>\{{formatNumber percentApprovalFailure style="percent"}}</td>
                </tr>
            \{{/each}}
            </tbody>
        </table>
    </script>

    <h3>Percent retweeted and unreviewed relative to total matches:</h3>
    <div class="row">
        <svg id="percent-reviewed-unreviewed-by-date-created-chart" height="400"></svg>
    </div>
    <h3>Counts of things that happened by date match created:</h3>
    <div class="row">
        <svg id="counts-by-date-created-chart" height="400"></svg>
    </div>
    <h3>Percent approval failure out of all approval attempts:</h3>
    <div class="row">
        <svg id="percent-approval-failure-by-date-created-chart" height="400"></svg>
    </div>

    <h3>
        <button class="btn btn-sm btn-info js-collapse-button" data-toggle="collapse" data-target="#stats-by-score-table"></button>
        Stats by interesting factor bucket:
    </h3>
    <div id="stats-by-score-table" class="row collapse in col-md-12"></div>

    <script id="stats-by-score-table-template" type="text/x-handlebars-template">
        <table class="table table-hover table-condensed">
            <thead>
            <tr>
                <th>Interesting Factor</th>
                <th>Total matches</th>
                <th>Attempted Approval</th>
                <th>Auto-rejected</th>
                <th>Retweeted</th>
                <th>Unretweeted</th>
                <th>Rejected</th>
                <th>Tumblr</th>
                <th>Unreviewed</th>
                <th>% Unreviewed</th>
                <th>% Retweeted</th>
            </tr>
            </thead>
            <tbody>
            \{{#each rows}}
                <tr>
                    <td>\{{formatNumber score minimumFractionDigits="2"}}</td>
                    <td>\{{matchesCreated}}</td>
                    <td>\{{attemptedApproval}}</td>
                    <td>\{{autoRejected}}</td>
                    <td>\{{retweeted}}</td>
                    <td>\{{unretweeted}}</td>
                    <td>\{{rejected}}</td>
                    <td>\{{postedToTumblr}}</td>
                    <td>\{{unreviewed}}</td>
                    <td>\{{formatNumber percentUnreviewed style="percent"}}</td>
                    <td>\{{formatNumber percentRetweeted style="percent"}}</td>
                </tr>
            \{{/each}}
            </tbody>
        </table>
    </script>

    <h3>Percent retweeted and unreviewed by interesting factor bucket:</h3>
    <div class="row">
        <svg id="reviewed-unreviewed-by-score-bucket-chart" height="400"></svg>
    </div>
    <h3>Totals by interesting factor bucket:</h3>
    <div class="row">
        <svg id="totals-by-score-bucket-chart" height="400"></svg>
    </div>

    <h3>
        <button class="btn btn-sm btn-info js-collapse-button" data-toggle="collapse"
                data-target="#stats-by-time-of-day-match-created-table"></button>
        Stats by time of day match created:
    </h3>

    <div id="stats-by-time-of-day-match-created-table" class="row collapse in col-md-12"></div>

    <script id="stats-by-time-of-day-match-created-table-template" type="text/x-handlebars-template">
        <table class="table table-hover table-condensed">
            <thead>
            <tr>
                <th>Time of Day</th>
                <th>Total matches</th>
                <th>Attempted Approval</th>
                <th>Auto-rejected</th>
                <th>Retweeted</th>
                <th>Unretweeted</th>
                <th>Rejected</th>
                <th>Tumblr</th>
                <th>Unreviewed</th>
                <th>% Unreviewed</th>
                <th>% Retweeted</th>
            </tr>
            </thead>
            <tbody>
            \{{#each rows}}
            <tr>
                <td>\{{formatTime timeOfDay hour="numeric" minute="numeric"}}</td>
                <td>\{{matchesCreated}}</td>
                <td>\{{attemptedApproval}}</td>
                <td>\{{autoRejected}}</td>
                <td>\{{retweeted}}</td>
                <td>\{{unretweeted}}</td>
                <td>\{{rejected}}</td>
                <td>\{{postedToTumblr}}</td>
                <td>\{{unreviewed}}</td>
                <td>\{{formatNumber percentUnreviewed style="percent"}}</td>
                <td>\{{formatNumber percentRetweeted style="percent"}}</td>
            </tr>
            \{{/each}}
            </tbody>
        </table>
    </script>

    <h3>Totals by time of day match created:</h3>
    <div class="row">
        <svg id="totals-by-time-of-day-match-created-chart" height="400"></svg>
    </div>

</div>

<script>
    $(() => {

        const defaultPropValueIsZeroHandler = {
            get: (target, name) => {
                return name in target ? target[name] : 0;
            }
        };

        Date.prototype.addDays = function(days) {
            const theDate = new Date(this.valueOf());
            theDate.setDate(theDate.getDate() + days);
            return theDate;
        };

        function getAllDatesBetween(startDate, stopDate) {
            const dateArray = [];
            let currentDate = startDate;
            while (currentDate <= stopDate) {
                dateArray.push(new Date(currentDate));
                currentDate = currentDate.addDays(1);
            }
            return dateArray;
        }

        function fillInMissingDays(data, dateKeySelector, valueSelector, missingValueSelector) {

            const dataByDay = new Map(data.map(x => [dateKeySelector(x).toDateString(), valueSelector(x)]));
            const dates = data.map(x => dateKeySelector(x));

            const firstDay = new Date(Math.min(...dates));
            const lastDay = new Date(Math.max(...dates));
            const contiguousDates = getAllDatesBetween(firstDay, lastDay);

            return contiguousDates.map(x => {
                if (dataByDay.has(x.toDateString())) {
                    return dataByDay.get(x.toDateString());
                } else {
                    return missingValueSelector(x);
                }
            });
        }

        function dateSeriesByProperty(data, ySelector) {
            return data.map(row => {
                return {x: row.day, y: ySelector(row)}
            });
        }

        function timeSeriesByProperty(data, ySelector) {
            return data.map(row => {
                return {x: row.timeOfDay, y: ySelector(row)}
            });
        }

        function scoreSeriesByProperty(data, ySelector) {
            return data.map(row => {
                return {x: row.score, y: ySelector(row)}
            });
        }

        class StatsByDateMatchPosted {
            constructor(row) {
                this.day = new Date(row.day);
                this.retweeted = Number(row.retweeted);
                this.postedToTumblr = Number(row.posted_to_tumblr);
            }
        }

        class StatsByDateMatchPostedSeriesCollection {
            constructor(statsByDateMatchPostedCollection) {
                const stats = statsByDateMatchPostedCollection;

                this.retweeted = dateSeriesByProperty(stats, x => x.retweeted);
                this.postedToTumblr = dateSeriesByProperty(stats, x => x.postedToTumblr);
            }
        }

        class StatsByDateMatchCreated {
            constructor(row) {
                this.day = new Date(row.day);
                this.matchesCreated = Number(row.matches_created);
                this.attemptedApproval = Number(row.attempted_approval);
                this.autoRejected = Number(row.auto_rejected);
                this.retweeted = Number(row.retweeted);
                this.unretweeted = Number(row.unretweeted);
                this.rejected = Number(row.rejected);
                this.postedToTumblr = Number(row.posted_to_tumblr);
                this.unreviewed = Number(row.unreviewed);

                this.percentUnreviewed = this.unreviewed / this.matchesCreated;
                this.percentRetweeted = this.retweeted / this.matchesCreated;

                const countOfAdditionalTumblrPostsMadeBecauseAMatchContainedAnAlreadyRetweetedTweet = this.postedToTumblr - this.retweeted;
                const numberOfAttemptedApprovalsNotCountingKnownUnretweetableMatches =
                        this.attemptedApproval - countOfAdditionalTumblrPostsMadeBecauseAMatchContainedAnAlreadyRetweetedTweet;

                this.adjustedFailedAttemptedApprovals = numberOfAttemptedApprovalsNotCountingKnownUnretweetableMatches - this.retweeted;
                this.percentApprovalFailure = (1 - (this.retweeted / numberOfAttemptedApprovalsNotCountingKnownUnretweetableMatches)) || 0;
            }
        }

        class StatsByDateMatchCreatedSeriesCollection {
            constructor(statsByDayMatchCreatedCollection) {

                const stats = statsByDayMatchCreatedCollection;

                this.matchesCreated = dateSeriesByProperty(stats, x => x.matchesCreated);
                this.attemptedApproval = dateSeriesByProperty(stats, x => x.attemptedApproval);
                this.autoRejected = dateSeriesByProperty(stats, x => x.autoRejected);
                this.retweeted = dateSeriesByProperty(stats, x => x.retweeted);
                this.unretweeted = dateSeriesByProperty(stats, x => x.unretweeted);
                this.rejected = dateSeriesByProperty(stats, x => x.rejected);
                this.postedToTumblr = dateSeriesByProperty(stats, x => x.postedToTumblr);
                this.unreviewed = dateSeriesByProperty(stats, x => x.unreviewed);
                this.adjustedFailedAttemptedApprovals = dateSeriesByProperty(stats, x => x.adjustedFailedAttemptedApprovals);

                this.percentUnreviewed = dateSeriesByProperty(stats, x => x.percentUnreviewed);
                this.percentRetweeted = dateSeriesByProperty(stats, x => x.percentRetweeted);
                this.percentApprovalFailure = dateSeriesByProperty(stats, x => x.percentApprovalFailure);
            }
        }

        class StatsByTimeOfDayMatchCreated {
            constructor(row) {

                const timeOfDay = new Date(0);
                timeOfDay.setHours(row.time_of_day.hours || 0);
                timeOfDay.setMinutes(row.time_of_day.minutes || 0);

                this.timeOfDay = timeOfDay.getTime();

                this.matchesCreated = Number(row.matches_created);
                this.attemptedApproval = Number(row.attempted_approval);
                this.autoRejected = Number(row.auto_rejected);
                this.retweeted = Number(row.retweeted);
                this.unretweeted = Number(row.unretweeted);
                this.rejected = Number(row.rejected);
                this.postedToTumblr = Number(row.posted_to_tumblr);
                this.unreviewed = Number(row.unreviewed);

                this.percentUnreviewed = this.unreviewed / this.matchesCreated;
                this.percentRetweeted = this.retweeted / this.matchesCreated;

                const countOfAdditionalTumblrPostsMadeBecauseAMatchContainedAnAlreadyRetweetedTweet = this.postedToTumblr - this.retweeted;
                const numberOfAttemptedApprovalsNotCountingKnownUnretweetableMatches =
                        this.attemptedApproval - countOfAdditionalTumblrPostsMadeBecauseAMatchContainedAnAlreadyRetweetedTweet;

                this.adjustedFailedAttemptedApprovals = numberOfAttemptedApprovalsNotCountingKnownUnretweetableMatches - this.retweeted;
                this.percentApprovalFailure = (1 - (this.retweeted / numberOfAttemptedApprovalsNotCountingKnownUnretweetableMatches)) || 0;
            }
        }

        class StatsByTimeOfDayMatchCreatedSeriesCollection {
            constructor(statsByTimeOfDayMatchCreatedCollection) {

                const stats = statsByTimeOfDayMatchCreatedCollection;

                this.matchesCreated = timeSeriesByProperty(stats, x => x.matchesCreated);
                this.attemptedApproval = timeSeriesByProperty(stats, x => x.attemptedApproval);
                this.autoRejected = timeSeriesByProperty(stats, x => x.autoRejected);
                this.retweeted = timeSeriesByProperty(stats, x => x.retweeted);
                this.unretweeted = timeSeriesByProperty(stats, x => x.unretweeted);
                this.rejected = timeSeriesByProperty(stats, x => x.rejected);
                this.postedToTumblr = timeSeriesByProperty(stats, x => x.postedToTumblr);
                this.unreviewed = timeSeriesByProperty(stats, x => x.unreviewed);
                this.adjustedFailedAttemptedApprovals = timeSeriesByProperty(stats, x => x.adjustedFailedAttemptedApprovals);

                this.percentUnreviewed = timeSeriesByProperty(stats, x => x.percentUnreviewed);
                this.percentRetweeted = timeSeriesByProperty(stats, x => x.percentRetweeted);
                this.percentApprovalFailure = timeSeriesByProperty(stats, x => x.percentApprovalFailure);
            }
        }

        class StatsByScoreBucket {
            constructor(row) {
                this.score = Number(row.score);
                this.matchesCreated = Number(row.matches_created);
                this.attemptedApproval = Number(row.attempted_approval);
                this.autoRejected = Number(row.auto_rejected);
                this.retweeted = Number(row.retweeted);
                this.unretweeted = Number(row.unretweeted);
                this.rejected = Number(row.rejected);
                this.postedToTumblr = Number(row.posted_to_tumblr);
                this.unreviewed = Number(row.unreviewed);

                this.percentUnreviewed = (this.unreviewed / this.matchesCreated) || 0;
                this.percentRetweeted = (this.retweeted / this.matchesCreated) || 0;
            }
        }

        class StatsByScoreBucketSeriesCollection {
            constructor(statsByScoreBucketCollection) {

                const stats = statsByScoreBucketCollection;

                this.matchesCreated = scoreSeriesByProperty(stats, x => x.matchesCreated);
                this.attemptedApproval = scoreSeriesByProperty(stats, x => x.attemptedApproval);
                this.autoRejected = scoreSeriesByProperty(stats, x => x.autoRejected);
                this.retweeted = scoreSeriesByProperty(stats, x => x.retweeted);
                this.unretweeted = scoreSeriesByProperty(stats, x => x.unretweeted);
                this.rejected = scoreSeriesByProperty(stats, x => x.rejected);
                this.postedToTumblr = scoreSeriesByProperty(stats, x => x.postedToTumblr);
                this.unreviewed = scoreSeriesByProperty(stats, x => x.unreviewed);

                this.percentUnreviewed = scoreSeriesByProperty(stats, x => x.percentUnreviewed);
                this.percentRetweeted = scoreSeriesByProperty(stats, x => x.percentRetweeted);
            }
        }

        function buildStatsByDateMatchPosted() {
            const stats = JSON.parse('{{{stats.retweetsAndTumblrByDayJson}}}')
                    .map(x => new StatsByDateMatchPosted(x));
            const statsWithDaysFilledIn = fillInMissingDays(stats, row => row.day, row => row,
                    day => new Proxy({day: day}, defaultPropValueIsZeroHandler));
            return {
                series: new StatsByDateMatchPostedSeriesCollection(statsWithDaysFilledIn),
                stats: [...statsWithDaysFilledIn].reverse()
            };
        }

        function buildStatsByDateMatchCreated() {
            const stats = JSON.parse('{{{stats.statsByDateMatchCreatedJson}}}')
                    .map(x => new StatsByDateMatchCreated(x));
            const statsWithDaysFilledIn = fillInMissingDays(stats, row => row.day, row => row,
                    day => new Proxy({day: day}, defaultPropValueIsZeroHandler));
            return {
                series: new StatsByDateMatchCreatedSeriesCollection(statsWithDaysFilledIn),
                stats: [...statsWithDaysFilledIn].reverse()
            };
        }

        function buildStatsByTimeOfDayMatchCreated() {
            const stats = JSON.parse('{{{stats.statsByTimeOfDayMatchCreatedJson}}}')
                    .map(x => new StatsByTimeOfDayMatchCreated(x));
            return {
                series: new StatsByTimeOfDayMatchCreatedSeriesCollection(stats),
                stats: stats
            };
        }

        function buildStatsByScoreBucket() {
            const stats = JSON.parse('{{{stats.statsByInterestingFactorBucketJson}}}')
                    .map(x => new StatsByScoreBucket(x)).reverse();

            var lastBucket = () => stats[stats.length - 1];
            while (lastBucket().score != 1.0) {
                stats.push(new Proxy({score: lastBucket().score + 0.01}, defaultPropValueIsZeroHandler));
            }
            return {
                series: new StatsByScoreBucketSeriesCollection(stats),
                stats: [...stats].reverse()
            };
        }

        function buildRetweetsAndTumblrPostsByDayChart(dayStats, cssSelector) {

            const data = [{
                values: dayStats.postedToTumblr,
                key: 'Tumblr',
            }, {
                values: dayStats.retweeted,
                key: 'Retweeted',
            }];

            nv.addGraph(() => {

                const chart = nv.models.multiBarChart()
                                .options({
                                    duration: 300
                                })
                                .margin({right: 50, bottom: 70})
                                .groupSpacing(0.4)
                                .color(d3.scale.category10().range())
                                .rotateLabels(45)
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .ticks(10)
                ;

                chart.yAxis
                        .axisLabel('Count')
                        .tickFormat(d3.format('i'))
                        .ticks(5)
                ;

                d3.select(cssSelector)
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildPercentApprovalFailureChart(dayStats, cssSelector) {
            const data = [{
                values: dayStats.percentApprovalFailure,
                key: 'Approval Failure',
                color: '#FF0000'
            }];

            nv.addGraph(() => {

                const chart = nv.models.lineWithFocusChart()
                                .options({
                                    useInteractiveGuideline: true,
                                    duration: 300,
                                })
                                .margin({bottom: 90, right: 70})
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .rotateLabels(45)
                ;

                chart.x2Axis.tickFormat((d) => {
                    return d3.time.format('%x')(new Date(d))
                });

                chart.yAxis
                        .axisLabel('Percent')
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                        .ticks(4)
                ;

                chart.y2Axis
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                ;

                d3.select(cssSelector)
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildRetweetedAndUnreviewedByDateMatchCreatedChart(dayStats, cssSelector) {

            const data = [{
                values: dayStats.percentUnreviewed,
                key: "Unreviewed",
            }, {
                values: dayStats.percentRetweeted,
                key: 'Retweeted',
            }];

            nv.addGraph(() => {

                const chart = nv.models.lineWithFocusChart()
                                .options({
                                    useInteractiveGuideline: true,
                                    duration: 300,
                                    forceY: [0, 1],
                                })
                                .color(d3.scale.category10().range())
                                .margin({bottom: 90, right: 70})
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .rotateLabels(45)
                ;

                chart.x2Axis.tickFormat((d) => {
                    return d3.time.format('%x')(new Date(d))
                });

                chart.yAxis
                        .axisLabel('Percent')
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                        .ticks(4)
                ;

                chart.y2Axis
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                ;

                d3.select(cssSelector)
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildCountsByDateMatchCreatedChart(dayStats, cssSelector) {

            const data = [{
                values: dayStats.unreviewed,
                key: 'Unreviewed',
            }, {
                values: dayStats.retweeted,
                key: 'Retweeted'
            }, {
                values: dayStats.matchesCreated,
                key: "Created",
            }, {
                values: dayStats.adjustedFailedAttemptedApprovals,
                key: 'Failed Attempted Approvals'
            }];

            nv.addGraph(() => {

                const chart = nv.models.multiBarChart()
                                .options({
                                    duration: 300
                                })
                                .margin({right: 50, bottom: 70})
                                .groupSpacing(0.4)
                                .color(d3.scale.category10().range())
                                .rotateLabels(45)
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .axisLabelDistance(30)
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .ticks(10)
                ;

                chart.yAxis
                        .axisLabel('Count')
                        .tickFormat(d3.format('i'))
                        .ticks(5)
                ;

                d3.select(cssSelector)
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildRetweetedAndUnreviewedByScoreBucketChart(scoreStats, cssSelector) {

            const scoreBucketData = [{
                values: scoreStats.percentRetweeted,
                key: 'Retweeted'
            }, {
                values: scoreStats.percentUnreviewed,
                key: "Unreviewed",
            }];

            nv.addGraph(() => {

                const chart = nv.models.lineChart()
                                .options({
                                    useInteractiveGuideline : true,
                                    duration: 300,
                                    forceY: [0, 1],
                                    forceX: [0.4, 1]
                                })
                                .color(d3.scale.category10().range())
                        ;

                chart.xAxis
                        .axisLabel("Interesting Factor")
                        .tickFormat(d3.format('.2f'))
                        .ticks(10)
                ;

                chart.yAxis
                        .axisLabel('Percent')
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                        .ticks(4)
                ;

                d3.select(cssSelector)
                        .datum(scoreBucketData)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildCountsByScoreBucketChart(scoreStats, cssSelector) {

            const data = [{
                values: scoreStats.retweeted,
                key: "Retweeted",
            }, {
                values: scoreStats.unreviewed,
                key: "Unreviewed",
            }, {
                values: scoreStats.matchesCreated,
                key: 'Created'
            }, {
                values: scoreStats.autoRejected,
                key: "Auto-Rejected"
            }];

            nv.addGraph(() => {

                const chart = nv.models.multiBarChart()
                                .options({
                                    duration: 300,
                                })
                                .color(d3.scale.category10().range())
                        ;

                chart.xAxis
                        .axisLabel("Date")
                ;

                chart.yAxis
                        .axisLabel('Count')
                        .tickFormat(d3.format('i'))
                ;

                d3.select(cssSelector)
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildCountsByTimeOfDayMatchCreatedChart(timeOfDayStats, cssSelector) {
            const data = [{
                values: timeOfDayStats.unreviewed,
                key: 'Unreviewed',
            }, {
                values: timeOfDayStats.retweeted,
                key: 'Retweeted'
            }, {
                values: timeOfDayStats.matchesCreated,
                key: "Created",
            }, {
                values: timeOfDayStats.adjustedFailedAttemptedApprovals,
                key: 'Failed Attempted Approvals'
            }];
            nv.addGraph(() => {

                const chart = nv.models.multiBarChart()
                                .options({
                                    duration: 300
                                })
                                .margin({right: 50, bottom: 70})
                                .groupSpacing(0.4)
                                .color(d3.scale.category10().range())
                                .rotateLabels(45)
                        ;

                chart.xAxis
                        .axisLabel("Time")
                        .axisLabelDistance(30)
                        .tickFormat((d) => {
                            return d3.time.format('%I:%M %p')(new Date(d))
                        })
                ;

                chart.yAxis
                        .axisLabel('Count')
                        .tickFormat(d3.format('i'))
                ;

                d3.select(cssSelector)
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        const $jsCollapseButtons = $(".js-collapse-button");
        $jsCollapseButtons.text("➖");
        $jsCollapseButtons.click(function() {
            $(this).text(function (i, previous) {
                return previous == '➕' ? '➖' : '➕';
            });
        });

        const byDayMatchPosted = buildStatsByDateMatchPosted();
        const byDayMatchCreated = buildStatsByDateMatchCreated();
        const byScoreBucket = buildStatsByScoreBucket();
        const byTimeOfDayMatchCreated = buildStatsByTimeOfDayMatchCreated();

        buildRetweetsAndTumblrPostsByDayChart(byDayMatchPosted.series, '#retweets-and-tumblr-posts-by-day-chart');
        buildRetweetedAndUnreviewedByDateMatchCreatedChart(byDayMatchCreated.series, '#percent-reviewed-unreviewed-by-date-created-chart');
        buildPercentApprovalFailureChart(byDayMatchCreated.series, '#percent-approval-failure-by-date-created-chart');
        buildCountsByDateMatchCreatedChart(byDayMatchCreated.series, '#counts-by-date-created-chart');
        buildRetweetedAndUnreviewedByScoreBucketChart(byScoreBucket.series, '#reviewed-unreviewed-by-score-bucket-chart');
        buildCountsByScoreBucketChart(byScoreBucket.series, '#totals-by-score-bucket-chart');
        buildCountsByTimeOfDayMatchCreatedChart(byTimeOfDayMatchCreated.series, '#totals-by-time-of-day-match-created-chart');

        HandlebarsIntl.registerWith(Handlebars);

        function renderTable($template, $target, data) {
            const template = Handlebars.compile($template.html());
            const html = template({rows: data});
            $target.html(html);
        }

        renderTable($("#retweets-and-tumblr-posts-by-day-table-template"),
                    $("#retweets-and-tumblr-posts-by-day-table"), byDayMatchPosted.stats);

        renderTable($("#stats-by-date-created-table-template"),
                    $("#stats-by-date-created-table"), byDayMatchCreated.stats);

        renderTable($("#stats-by-score-table-template"),
                    $("#stats-by-score-table"), byScoreBucket.stats);

        renderTable($("#stats-by-time-of-day-match-created-table-template"),
                    $("#stats-by-time-of-day-match-created-table"), byTimeOfDayMatchCreated.stats);

    });

</script>