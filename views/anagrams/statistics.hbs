<div class="container-fluid">

    <h3>Important</h3>
    <div class="row">
        There

        {{#if stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoffIsOne}}
            is
        {{else}}
            are
        {{/if}}

        <strong>{{formatNumber stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoff}}</strong>

        {{#if stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoffIsOne}}
            match
        {{else}}
            matches
        {{/if}}

        with an interesting factor above <strong>{{stats.interestingFactorCutoff}}</strong> that

        {{#if stats.countOfNotRejectedAndNotApprovedMatchesAboveCutoffIsOne}}
            is
        {{else}}
            are
        {{/if}}

        not rejected, not retweeted, and not posted to tumblr.
    </div>
    <h3>Fun</h3>
    <div class="row">
        There are <strong>{{formatNumber stats.countOfMatches}}</strong> total matches over approximately
        <strong>{{formatNumber stats.approximateCountOfTweets}}</strong> tweets. That's about
        <strong>{{formatNumber stats.tweetsPerMatch maximumFractionDigits="0"}}</strong> tweets per match!
    </div>
    <div class="row">
        There are <strong>{{formatNumber stats.countOfMatchesAboveCutoff}}</strong> matches with an interesting factor
        above
        <strong>{{stats.interestingFactorCutoff}}</strong>.
    </div>
    <div class="row">
        <strong>{{formatNumber stats.countOfRetweetedMatches}}</strong> matches have been retweeted.
        There should be <strong>{{stats.countOfRetweetedTweets}}</strong> retweeted tweets.
    </div>
    <div class="row">
        <strong>{{formatNumber stats.countOfRejectedMatches}}</strong> matches have been rejected.
    </div>
    <div class="row">
        The most recent match was created <strong>{{formatRelative stats.dateLastMatchCreated}}</strong> at
        <strong>{{formatTime stats.dateLastMatchCreated hour="numeric" minute="numeric"}}</strong> on
        <strong>{{formatTime stats.dateLastMatchCreated day="numeric" month="long" year="numeric" }}</strong>.
    </div>

    <h3>
        <button class="btn btn-sm btn-info js-collapse-button" data-toggle="collapse" data-target="#retweets-and-tumblr-posts-by-day-table"></button>
        Retweets and Tumblr posts made by day for the past <strong>{{stats.numberOfDaysToGetMatchesPerDay}}</strong> days:
    </h3>
    <div id="retweets-and-tumblr-posts-by-day-table" class="row collapse in">
        <div class="col-md-5">
            <table class="table table-hover table-condensed">
                <thead>
                <tr>
                    <th>Day</th>
                    <th>Retweets</th>
                    <th>Tumblr posts</th>
                </tr>
                </thead>
                <tbody>
                {{#each stats.retweetsAndTumblrByDay}}
                    <tr>
                        <td>{{formatTime day day="numeric" month="long" year="numeric"}}</td>
                        <td>{{retweeted}}</td>
                        <td>{{posted_to_tumblr}}</td>
                    </tr>
                {{/each}}
                </tbody>
            </table>
        </div>
        <div class="col-md-7">
            <svg id="retweets-and-tumblr-posts-by-day-chart" height="400"></svg>
        </div>
    </div>

    <h3>
        <button class="btn btn-sm btn-info js-collapse-button" data-toggle="collapse" data-target="#stats-by-date-created-table"></button>
        Stats by date match created for the past <strong>{{stats.numberOfDaysToGetMatchesPerDay}}</strong> days:
    </h3>
    <div id="stats-by-date-created-table" class="row collapse in">
        <div class="col-md-12">
            <table class="table table-hover table-condensed">
                <thead>
                <tr>
                    <th>Day</th>
                    <th>Matches created</th>
                    <th>Attempted Approval</th>
                    <th>Auto-rejected</th>
                    <th>Retweeted</th>
                    <th>Unretweeted</th>
                    <th>Rejected</th>
                    <th>Tumblr</th>
                    <th>Unreviewed</th>
                    <th>% Unreviewed</th>
                    <th>% Retweeted</th>
                    <th>% Approval Failure</th>
                </tr>
                </thead>
                <tbody>
                {{#each stats.statsByDateMatchCreated}}
                    <tr>
                        <td>{{formatTime day day="numeric" month="long" year="numeric"}}</td>
                        <td>{{matches_created}}</td>
                        <td>{{attempted_approval}}</td>
                        <td>{{auto_rejected}}</td>
                        <td>{{retweeted}}</td>
                        <td>{{unretweeted}}</td>
                        <td>{{rejected}}</td>
                        <td>{{posted_to_tumblr}}</td>
                        <td>{{unreviewed}}</td>
                        <td>{{formatNumber percentUnreviewed style="percent"}}</td>
                        <td>{{formatNumber percentRetweeted style="percent"}}</td>
                        <td>{{formatNumber percentApprovalFailure style="percent"}}</td>
                    </tr>
                {{/each}}
                </tbody>
            </table>
        </div>
    </div>
    <h3>Percent retweeted and unreviewed relative to total matches:</h3>
    <div class="row">
        <svg id="percent-reviewed-unreviewed-by-date-created-chart" height="400"></svg>
    </div>
    <h3>Counts of things that happened by date match created:</h3>
    <div class="row">
        <svg id="counts-by-date-created-chart" height="400"></svg>
    </div>
    <h3>Percent approval failure out of all approval attempts:</h3>
    <div class="row">
        <svg id="percent-approval-failure-by-date-created-chart" height="400"></svg>
    </div>

    <h3>
        <button class="btn btn-sm btn-info js-collapse-button" data-toggle="collapse" data-target="#stats-by-score-table"></button>
        Stats by interesting factor bucket:
    </h3>
    <div id="stats-by-score-table" class="row collapse in">
        <div class="col-md-12">
            <table class="table table-hover table-condensed">

                <thead>
                <tr>
                    <th>Interesting Factor</th>
                    <th>Total matches</th>
                    <th>Attempted Approval</th>
                    <th>Auto-rejected</th>
                    <th>Retweeted</th>
                    <th>Unretweeted</th>
                    <th>Rejected</th>
                    <th>Tumblr</th>
                    <th>Unreviewed</th>
                    <th>% Unreviewed</th>
                    <th>% Retweeted</th>
                </tr>
                </thead>
                <tbody>
                {{#each stats.statsByInterestingFactorBucket}}
                    <tr>
                        <td>{{score}}</td>
                        <td>{{matches_created}}</td>
                        <td>{{attempted_approval}}</td>
                        <td>{{auto_rejected}}</td>
                        <td>{{retweeted}}</td>
                        <td>{{unretweeted}}</td>
                        <td>{{rejected}}</td>
                        <td>{{posted_to_tumblr}}</td>
                        <td>{{unreviewed}}</td>
                        <td>{{formatNumber percentUnreviewed style="percent"}}</td>
                        <td>{{formatNumber percentRetweeted style="percent"}}</td>
                    </tr>
                {{/each}}
                </tbody>
            </table>
        </div>
    </div>
    <h3>Percent retweeted and unreviewed by interesting factor bucket:</h3>
    <div class="row">
        <svg id="reviewed-unreviewed-by-score-bucket-chart" height="400"></svg>
    </div>
    <h3>Totals by interesting factor bucket:</h3>
    <div class="row">
        <svg id="totals-by-score-bucket-chart" height="400"></svg>
    </div>
</div>

<script>
    $(() => {

        const defaultPropValueIsZeroHandler = {
            get: (target, name) => {
                return name in target ? target[name] : 0;
            }
        };

        Date.prototype.addDays = function(days) {
            const theDate = new Date(this.valueOf());
            theDate.setDate(theDate.getDate() + days);
            return theDate;
        };

        function getAllDatesBetween(startDate, stopDate) {
            const dateArray = [];
            let currentDate = startDate;
            while (currentDate <= stopDate) {
                dateArray.push(new Date(currentDate));
                currentDate = currentDate.addDays(1);
            }
            return dateArray;
        }

        function fillInMissingDays(data, dateKeySelector, valueSelector, missingValueSelector) {

            const dataByDay = new Map(data.map(x => [dateKeySelector(x).toDateString(), valueSelector(x)]));
            const dates = data.map(x => dateKeySelector(x));

            const firstDay = new Date(Math.min(...dates));
            const lastDay = new Date(Math.max(...dates));
            const contiguousDates = getAllDatesBetween(firstDay, lastDay);

            return contiguousDates.map(x => {
                if (dataByDay.has(x.toDateString())) {
                    return dataByDay.get(x.toDateString());
                } else {
                    return missingValueSelector(x);
                }
            });
        }

        function dateSeriesByProperty(data, ySelector) {
            return data.map(row => {
                return {x: row.day, y: ySelector(row)}
            });
        }

        function scoreSeriesByProperty(data, ySelector) {
            return data.map(row => {
                return {x: row.score, y: ySelector(row)}
            });
        }

        class StatsByDateMatchPosted {
            constructor(row) {
                this.day = new Date(row.day);
                this.retweeted = Number(row.retweeted);
                this.postedToTumblr = Number(row.posted_to_tumblr);
            }
        }

        class StatsByDateMatchPostedSeriesCollection {
            constructor(statsByDateMatchPostedCollection) {
                const stats = statsByDateMatchPostedCollection;

                this.retweeted = dateSeriesByProperty(stats, x => x.retweeted);
                this.postedToTumblr = dateSeriesByProperty(stats, x => x.postedToTumblr);
            }
        }

        class StatsByDateMatchCreated {
            constructor(row) {
                this.day = new Date(row.day);
                this.matchesCreated = Number(row.matches_created);
                this.attemptedApproval = Number(row.attempted_approval);
                this.autoRejected = Number(row.auto_rejected);
                this.retweeted = Number(row.retweeted);
                this.unretweeted = Number(row.unretweeted);
                this.rejected = Number(row.rejected);
                this.postedToTumblr = Number(row.posted_to_tumblr);
                this.unreviewed = Number(row.unreviewed);
                this.adjustedFailedAttemptedApprovals = Number(row.adjustedFailedAttemptedApprovals);

                this.percentUnreviewed = Number(row.percentUnreviewed) || 0;
                this.percentRetweeted = Number(row.percentRetweeted) || 0;
                this.percentApprovalFailure = Number(row.percentApprovalFailure) || 0;
            }
        }

        class StatsByDateMatchCreatedSeriesCollection {
            constructor(statsByDayMatchCreatedCollection) {

                const stats = statsByDayMatchCreatedCollection;

                this.matchesCreated = dateSeriesByProperty(stats, x => x.matchesCreated);
                this.attemptedApproval = dateSeriesByProperty(stats, x => x.attemptedApproval);
                this.autoRejected = dateSeriesByProperty(stats, x => x.autoRejected);
                this.retweeted = dateSeriesByProperty(stats, x => x.retweeted);
                this.unretweeted = dateSeriesByProperty(stats, x => x.unretweeted);
                this.rejected = dateSeriesByProperty(stats, x => x.rejected);
                this.postedToTumblr = dateSeriesByProperty(stats, x => x.postedToTumblr);
                this.unreviewed = dateSeriesByProperty(stats, x => x.unreviewed);
                this.adjustedFailedAttemptedApprovals = dateSeriesByProperty(stats, x => x.adjustedFailedAttemptedApprovals);

                this.percentUnreviewed = dateSeriesByProperty(stats, x => x.percentUnreviewed);
                this.percentRetweeted = dateSeriesByProperty(stats, x => x.percentRetweeted);
                this.percentApprovalFailure = dateSeriesByProperty(stats, x => x.percentApprovalFailure);
            }
        }

        class StatsByScoreBucket {
            constructor(row) {
                this.score = Number(row.score);
                this.matchesCreated = Number(row.matches_created);
                this.attemptedApproval = Number(row.attempted_approval);
                this.autoRejected = Number(row.auto_rejected);
                this.retweeted = Number(row.retweeted);
                this.unretweeted = Number(row.unretweeted);
                this.rejected = Number(row.rejected);
                this.postedToTumblr = Number(row.posted_to_tumblr);
                this.unreviewed = Number(row.unreviewed);

                this.percentUnreviewed = Number(row.percentUnreviewed) || 0;
                this.percentRetweeted = Number(row.percentRetweeted) || 0;
            }
        }

        class StatsByScoreBucketSeriesCollection {
            constructor(statsByScoreBucketCollection) {

                const stats = statsByScoreBucketCollection;

                this.matchesCreated = scoreSeriesByProperty(stats, x => x.matchesCreated);
                this.attemptedApproval = scoreSeriesByProperty(stats, x => x.attemptedApproval);
                this.autoRejected = scoreSeriesByProperty(stats, x => x.autoRejected);
                this.retweeted = scoreSeriesByProperty(stats, x => x.retweeted);
                this.unretweeted = scoreSeriesByProperty(stats, x => x.unretweeted);
                this.rejected = scoreSeriesByProperty(stats, x => x.rejected);
                this.postedToTumblr = scoreSeriesByProperty(stats, x => x.postedToTumblr);
                this.unreviewed = scoreSeriesByProperty(stats, x => x.unreviewed);

                this.percentUnreviewed = scoreSeriesByProperty(stats, x => x.percentUnreviewed);
                this.percentRetweeted = scoreSeriesByProperty(stats, x => x.percentRetweeted);
            }
        }

        function buildStatsByDateMatchPosted() {
            const stats = JSON.parse('{{{stats.retweetsAndTumblrByDayJson}}}')
                    .map(x => new StatsByDateMatchPosted(x)).reverse();
            const statsWithDaysFilledIn = fillInMissingDays(stats, row => row.day, row => row,
                    day => new Proxy({day: day}, defaultPropValueIsZeroHandler));
            return {
                series: new StatsByDateMatchPostedSeriesCollection(statsWithDaysFilledIn),
                stats: statsWithDaysFilledIn
            };
        }

        function buildStatsByDateMatchCreated() {
            const stats = JSON.parse('{{{stats.statsByDateMatchCreatedJson}}}')
                    .map(x => new StatsByDateMatchCreated(x)).reverse();
            const statsWithDaysFilledIn = fillInMissingDays(stats, row => row.day, row => row,
                    day => new Proxy({day: day}, defaultPropValueIsZeroHandler));
            return {
                series: new StatsByDateMatchCreatedSeriesCollection(statsWithDaysFilledIn),
                stats: statsWithDaysFilledIn};
        }

        function buildStatsByScoreBucket() {
            const stats = JSON.parse('{{{stats.statsByInterestingFactorBucketJson}}}')
                    .map(x => new StatsByScoreBucket(x)).reverse();

            var lastBucket = () => stats[stats.length - 1];
            while (lastBucket().score != 1.0) {
                stats.push(new Proxy({score: lastBucket().score + 0.01}, defaultPropValueIsZeroHandler));
            }
            return {
                series: new StatsByScoreBucketSeriesCollection(stats),
                stats: stats
            };
        }

        function buildRetweetsAndTumblrPostsByDay(dayStats) {

            const data = [{
                values: dayStats.postedToTumblr,
                key: 'Tumblr',
            }, {
                values: dayStats.retweeted,
                key: 'Retweeted',
            }];

            nv.addGraph(() => {

                const chart = nv.models.multiBarChart()
                                .options({
                                    duration: 300
                                })
                                .margin({right: 50, bottom: 70})
                                .groupSpacing(0.4)
                                .color(d3.scale.category10().range())
                                .rotateLabels(45)
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .ticks(10)
                ;

                chart.yAxis
                        .axisLabel('Count')
                        .tickFormat(d3.format('i'))
                        .ticks(5)
                ;

                d3.select('#retweets-and-tumblr-posts-by-day-chart')
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildPercentApprovalFailureChart(dayStats) {
            const data = [{
                values: dayStats.percentApprovalFailure,
                key: 'Approval Failure',
                color: '#FF0000'
            }];

            nv.addGraph(() => {

                const chart = nv.models.lineWithFocusChart()
                                .options({
                                    useInteractiveGuideline: true,
                                    duration: 300,
                                })
                                .margin({bottom: 90, right: 70})
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .rotateLabels(45)
                ;

                chart.x2Axis.tickFormat((d) => {
                    return d3.time.format('%x')(new Date(d))
                });

                chart.yAxis
                        .axisLabel('Percent')
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                        .ticks(4)
                ;

                chart.y2Axis
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                ;

                d3.select('#percent-approval-failure-by-date-created-chart')
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildRetweetedAndUnreviewedByDateMatchCreatedChart(dayStats) {

            const data = [{
                values: dayStats.percentUnreviewed,
                key: "Unreviewed",
            }, {
                values: dayStats.percentRetweeted,
                key: 'Retweeted',
            }];

            nv.addGraph(() => {

                const chart = nv.models.lineWithFocusChart()
                                .options({
                                    useInteractiveGuideline: true,
                                    duration: 300,
                                    forceY: [0, 1],
                                })
                                .color(d3.scale.category10().range())
                                .margin({bottom: 90, right: 70})
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .rotateLabels(45)
                ;

                chart.x2Axis.tickFormat((d) => {
                    return d3.time.format('%x')(new Date(d))
                });

                chart.yAxis
                        .axisLabel('Percent')
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                        .ticks(4)
                ;

                chart.y2Axis
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                ;

                d3.select('#percent-reviewed-unreviewed-by-date-created-chart')
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildCountsByDateMatchCreatedChart(dayStats) {

            const data = [{
                values: dayStats.unreviewed,
                key: 'Unreviewed',
            }, {
                values: dayStats.retweeted,
                key: 'Retweeted'
            }, {
                values: dayStats.matchesCreated,
                key: "Created",
            }, {
                values: dayStats.adjustedFailedAttemptedApprovals,
                key: 'Failed Attempted Approvals'
            }];

            nv.addGraph(() => {

                const chart = nv.models.multiBarChart()
                                .options({
                                    duration: 300
                                })
                                .margin({right: 50, bottom: 70})
                                .groupSpacing(0.4)
                                .color(d3.scale.category10().range())
                                .rotateLabels(45)
                        ;

                chart.xAxis
                        .axisLabel("Date")
                        .axisLabelDistance(30)
                        .tickFormat((d) => {
                            return d3.time.format('%x')(new Date(d))
                        })
                        .ticks(10)
                ;

                chart.yAxis
                        .axisLabel('Count')
                        .tickFormat(d3.format('i'))
                        .ticks(5)
                ;

                d3.select('#counts-by-date-created-chart')
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildRetweetedAndUnreviewedByScoreBucketChart(scoreStats) {

            const scoreBucketData = [{
                values: scoreStats.percentRetweeted,
                key: 'Retweeted'
            }, {
                values: scoreStats.percentUnreviewed,
                key: "Unreviewed",
            }];

            nv.addGraph(() => {

                const chart = nv.models.lineChart()
                                .options({
                                    useInteractiveGuideline : true,
                                    duration: 300,
                                    forceY: [0, 1],
                                    forceX: [0.4, 1]
                                })
                                .color(d3.scale.category10().range())
                        ;

                chart.xAxis
                        .axisLabel("Interesting Factor")
                        .tickFormat(d3.format('.2f'))
                        .ticks(10)
                ;

                chart.yAxis
                        .axisLabel('Percent')
                        .tickFormat((d) => {
                            if (d == null) {
                                return 'N/A';
                            }
                            return d3.format('.2%')(d);
                        })
                        .ticks(4)
                ;

                d3.select('#reviewed-unreviewed-by-score-bucket-chart')
                        .datum(scoreBucketData)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        function buildCountsByScoreBucketChart(scoreStats) {

            const data = [{
                values: scoreStats.retweeted,
                key: "Retweeted",
            }, {
                values: scoreStats.unreviewed,
                key: "Unreviewed",
            }, {
                values: scoreStats.matchesCreated,
                key: 'Created'
            }, {
                values: scoreStats.autoRejected,
                key: "Auto-Rejected"
            }];

            nv.addGraph(() => {

                const chart = nv.models.multiBarChart()
                                .options({
                                    duration: 300,
                                })
                                .color(d3.scale.category10().range())
                        ;

                chart.xAxis
                        .axisLabel("Date")
                ;

                chart.yAxis
                        .axisLabel('Count')
                        .tickFormat(d3.format('i'))
                ;

                d3.select('#totals-by-score-bucket-chart')
                        .datum(data)
                        .call(chart);

                nv.utils.windowResize(chart.update);

                return chart;
            });
        }

        const byDayMatchPosted = buildStatsByDateMatchPosted();
        const byDayMatchCreated = buildStatsByDateMatchCreated();
        const byScoreBucket = buildStatsByScoreBucket();

        buildRetweetsAndTumblrPostsByDay(byDayMatchPosted.series);
        buildRetweetedAndUnreviewedByDateMatchCreatedChart(byDayMatchCreated.series);
        buildPercentApprovalFailureChart(byDayMatchCreated.series);
        buildCountsByDateMatchCreatedChart(byDayMatchCreated.series);
        buildRetweetedAndUnreviewedByScoreBucketChart(byScoreBucket.series);
        buildCountsByScoreBucketChart(byScoreBucket.series);

        const $jsCollapseButtons = $(".js-collapse-button");
        $jsCollapseButtons.text("➖");
        $jsCollapseButtons.click(function() {
            $(this).text(function (i, previous) {
                return previous == '➕' ? '➖' : '➕';
            });
        })
    });

</script>